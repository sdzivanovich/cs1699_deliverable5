<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=CP437">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE Trustworthy #-}
<span class="lineno">    2 </span>{-# LANGUAGE CPP, NoImplicitPrelude, ScopedTypeVariables, MagicHash #-}
<span class="lineno">    3 </span>{-# LANGUAGE BangPatterns #-}
<span class="lineno">    4 </span>{-# OPTIONS_HADDOCK hide #-}
<span class="lineno">    5 </span>
<span class="lineno">    6 </span>-----------------------------------------------------------------------------
<span class="lineno">    7 </span>-- |
<span class="lineno">    8 </span>-- Module      :  GHC.List
<span class="lineno">    9 </span>-- Copyright   :  (c) The University of Glasgow 1994-2002
<span class="lineno">   10 </span>-- License     :  see libraries/base/LICENSE
<span class="lineno">   11 </span>--
<span class="lineno">   12 </span>-- Maintainer  :  cvs-ghc@haskell.org
<span class="lineno">   13 </span>-- Stability   :  internal
<span class="lineno">   14 </span>-- Portability :  non-portable (GHC Extensions)
<span class="lineno">   15 </span>--
<span class="lineno">   16 </span>-- The List data type and its operations
<span class="lineno">   17 </span>--
<span class="lineno">   18 </span>-----------------------------------------------------------------------------
<span class="lineno">   19 </span>
<span class="lineno">   20 </span>-- NOTE: This code was adapted from the GHC.List module specified above.
<span class="lineno">   21 </span>-- All licensing remains as specified above. 
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>module MyList (
<span class="lineno">   24 </span>   -- [] (..),          -- built-in syntax; can't be used in export list
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>   map, (++), filter, concat,
<span class="lineno">   27 </span>   head, last, tail, init, uncons, null, length, (!!),
<span class="lineno">   28 </span>   intersperse, intercalate, subsequences, permutations,
<span class="lineno">   29 </span>   foldl, foldl1, foldr, foldr1,
<span class="lineno">   30 </span>   iterate, repeat, replicate, cycle,
<span class="lineno">   31 </span>   take, drop, sum, product, maximum, minimum, splitAt, takeWhile, dropWhile,
<span class="lineno">   32 </span>   span, break, reverse, and, or,
<span class="lineno">   33 </span>   elem, notElem, lookup,
<span class="lineno">   34 </span>   concatMap,
<span class="lineno">   35 </span>   zip, zipWith, unzip,
<span class="lineno">   36 </span>   errorEmptyList, sort
<span class="lineno">   37 </span>
<span class="lineno">   38 </span> ) where
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>import Data.Maybe
<span class="lineno">   41 </span>import GHC.Base
<span class="lineno">   42 </span>import GHC.Num (Num(..))
<span class="lineno">   43 </span>import GHC.Integer (Integer)
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>infixl 9  !!
<span class="lineno">   46 </span>infix  4 `elem`, `notElem`
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>sort :: (Ord a) =&gt; [a] -&gt; [a]
<span class="lineno">   50 </span><span class="decl"><span class="istickedoff">sort = foldr (insertBy compare) []</span></span>
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>-- | The non-overloaded version of 'insert'.
<span class="lineno">   53 </span>insertBy :: (a -&gt; a -&gt; Ordering) -&gt; a -&gt; [a] -&gt; [a]
<span class="lineno">   54 </span><span class="decl"><span class="istickedoff">insertBy _   x [] = [x]</span>
<span class="lineno">   55 </span><span class="spaces"></span><span class="istickedoff">insertBy cmp x ys@(y:ys')</span>
<span class="lineno">   56 </span><span class="spaces"> </span><span class="istickedoff">= case cmp x y of</span>
<span class="lineno">   57 </span><span class="spaces">     </span><span class="istickedoff">GT -&gt; y : insertBy cmp x ys'</span>
<span class="lineno">   58 </span><span class="spaces">     </span><span class="istickedoff">_  -&gt; x : ys</span></span>
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>--------------------------------------------------------------
<span class="lineno">   61 </span>-- List-manipulation functions
<span class="lineno">   62 </span>--------------------------------------------------------------
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>-- | Extract the first element of a list, which must be non-empty.
<span class="lineno">   65 </span>head                    :: [a] -&gt; a
<span class="lineno">   66 </span><span class="decl"><span class="istickedoff">head (x:_)              =  x</span>
<span class="lineno">   67 </span><span class="spaces"></span><span class="istickedoff">head []                 =  <span class="nottickedoff">badHead</span></span></span>
<span class="lineno">   68 </span>{-# NOINLINE [1] head #-}
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>badHead :: a
<span class="lineno">   71 </span><span class="decl"><span class="nottickedoff">badHead = errorEmptyList &quot;head&quot;</span></span>
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>-- This rule is useful in cases like
<span class="lineno">   74 </span>--      head [y | (x,y) &lt;- ps, x==t]
<span class="lineno">   75 </span>{-# RULES
<span class="lineno">   76 </span>&quot;head/build&quot;    forall (g::forall b.(a-&gt;b-&gt;b)-&gt;b-&gt;b) .
<span class="lineno">   77 </span>                head (build g) = g (\x _ -&gt; x) badHead
<span class="lineno">   78 </span>&quot;head/augment&quot;  forall xs (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<span class="lineno">   79 </span>                head (augment g xs) = g (\x _ -&gt; x) (head xs)
<span class="lineno">   80 </span> #-}
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>-- | Decompose a list into its head and tail. If the list is empty,
<span class="lineno">   83 </span>-- returns 'Nothing'. If the list is non-empty, returns @'Just' (x, xs)@,
<span class="lineno">   84 </span>-- where @x@ is the head of the list and @xs@ its tail.
<span class="lineno">   85 </span>--
<span class="lineno">   86 </span>-- @since 4.8.0.0
<span class="lineno">   87 </span>uncons                  :: [a] -&gt; Maybe (a, [a])
<span class="lineno">   88 </span><span class="decl"><span class="istickedoff">uncons []               = Nothing</span>
<span class="lineno">   89 </span><span class="spaces"></span><span class="istickedoff">uncons (x:xs)           = Just (x, xs)</span></span>
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>-- | Extract the elements after the head of a list, which must be non-empty.
<span class="lineno">   92 </span>tail                    :: [a] -&gt; [a]
<span class="lineno">   93 </span><span class="decl"><span class="istickedoff">tail (_:xs)             =  xs</span>
<span class="lineno">   94 </span><span class="spaces"></span><span class="istickedoff">tail []                 =  <span class="nottickedoff">errorEmptyList &quot;tail&quot;</span></span></span>
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>-- | Extract the last element of a list, which must be finite and non-empty.
<span class="lineno">   97 </span>last                    :: [a] -&gt; a
<span class="lineno">   98 </span>#ifdef USE_REPORT_PRELUDE
<span class="lineno">   99 </span>last [x]                =  x
<span class="lineno">  100 </span>last (_:xs)             =  last xs
<span class="lineno">  101 </span>last []                 =  errorEmptyList &quot;last&quot;
<span class="lineno">  102 </span>#else
<span class="lineno">  103 </span>-- use foldl to allow fusion
<span class="lineno">  104 </span><span class="decl"><span class="istickedoff">last = foldl (\_ x -&gt; x) <span class="nottickedoff">(errorEmptyList &quot;last&quot;)</span></span></span>
<span class="lineno">  105 </span>#endif
<span class="lineno">  106 </span>
<span class="lineno">  107 </span>-- | Return all the elements of a list except the last one.
<span class="lineno">  108 </span>-- The list must be non-empty.
<span class="lineno">  109 </span>init                    :: [a] -&gt; [a]
<span class="lineno">  110 </span>#ifdef USE_REPORT_PRELUDE
<span class="lineno">  111 </span>init [x]                =  []
<span class="lineno">  112 </span>init (x:xs)             =  x : init xs
<span class="lineno">  113 </span>init []                 =  errorEmptyList &quot;init&quot;
<span class="lineno">  114 </span>#else
<span class="lineno">  115 </span>-- eliminate repeated cases
<span class="lineno">  116 </span><span class="decl"><span class="istickedoff">init []                 =  <span class="nottickedoff">errorEmptyList &quot;init&quot;</span></span>
<span class="lineno">  117 </span><span class="spaces"></span><span class="istickedoff">init (x:xs)             =  init' x xs</span>
<span class="lineno">  118 </span><span class="spaces">  </span><span class="istickedoff">where init' _ []     = []</span>
<span class="lineno">  119 </span><span class="spaces">        </span><span class="istickedoff">init' y (z:zs) = y : init' z zs</span></span>
<span class="lineno">  120 </span>#endif
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>-- | Test whether a list is empty.
<span class="lineno">  123 </span>null                    :: [a] -&gt; Bool
<span class="lineno">  124 </span><span class="decl"><span class="istickedoff">null []                 =  True</span>
<span class="lineno">  125 </span><span class="spaces"></span><span class="istickedoff">null (_:_)              =  False</span></span>
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>-- | /O(n)/. 'length' returns the length of a finite list as an 'Int'.
<span class="lineno">  128 </span>-- It is an instance of the more general 'Data.List.genericLength',
<span class="lineno">  129 </span>-- the result type of which may be any kind of number.
<span class="lineno">  130 </span>{-# NOINLINE [1] length #-}
<span class="lineno">  131 </span>length                  :: [a] -&gt; Int
<span class="lineno">  132 </span><span class="decl"><span class="istickedoff">length xs               = lenAcc xs 0</span></span>
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>lenAcc          :: [a] -&gt; Int -&gt; Int
<span class="lineno">  135 </span><span class="decl"><span class="istickedoff">lenAcc []     n = n</span>
<span class="lineno">  136 </span><span class="spaces"></span><span class="istickedoff">lenAcc (_:ys) n = lenAcc ys (n+1)</span></span>
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>-- | 'filter', applied to a predicate and a list, returns the list of
<span class="lineno">  139 </span>-- those elements that satisfy the predicate; i.e.,
<span class="lineno">  140 </span>--
<span class="lineno">  141 </span>-- &gt; filter p xs = [ x | x &lt;- xs, p x]
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>{-# NOINLINE [1] filter #-}
<span class="lineno">  144 </span>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
<span class="lineno">  145 </span><span class="decl"><span class="istickedoff">filter _pred []    = []</span>
<span class="lineno">  146 </span><span class="spaces"></span><span class="istickedoff">filter pred (x:xs)</span>
<span class="lineno">  147 </span><span class="spaces">  </span><span class="istickedoff">| pred x         = x : filter pred xs</span>
<span class="lineno">  148 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>      = filter pred xs</span></span>
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>-- Note the filterFB rule, which has p and q the &quot;wrong way round&quot; in the RHS.
<span class="lineno">  151 </span>--     filterFB (filterFB c p) q a b
<span class="lineno">  152 </span>--   = if q a then filterFB c p a b else b
<span class="lineno">  153 </span>--   = if q a then (if p a then c a b else b) else b
<span class="lineno">  154 </span>--   = if q a &amp;&amp; p a then c a b else b
<span class="lineno">  155 </span>--   = filterFB c (\x -&gt; q x &amp;&amp; p x) a b
<span class="lineno">  156 </span>-- I originally wrote (\x -&gt; p x &amp;&amp; q x), which is wrong, and actually
<span class="lineno">  157 </span>-- gave rise to a live bug report.  SLPJ.
<span class="lineno">  158 </span>
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>-- | 'foldl', applied to a binary operator, a starting value (typically
<span class="lineno">  161 </span>-- the left-identity of the operator), and a list, reduces the list
<span class="lineno">  162 </span>-- using the binary operator, from left to right:
<span class="lineno">  163 </span>--
<span class="lineno">  164 </span>-- &gt; foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
<span class="lineno">  165 </span>--
<span class="lineno">  166 </span>-- The list must be finite.
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>-- We write foldl as a non-recursive thing, so that it
<span class="lineno">  169 </span>-- can be inlined, and then (often) strictness-analysed,
<span class="lineno">  170 </span>-- and hence the classic space leak on foldl (+) 0 xs
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
<span class="lineno">  173 </span>{-# INLINE foldl #-}
<span class="lineno">  174 </span><span class="decl"><span class="istickedoff">foldl k z0 xs =</span>
<span class="lineno">  175 </span><span class="spaces">  </span><span class="istickedoff">foldr (\(v::a) (fn::b-&gt;b) -&gt; (\(z::b) -&gt; fn (k z v))) (id :: b -&gt; b) xs z0</span></span>
<span class="lineno">  176 </span>  -- See Note [Left folds via right fold]
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>{-
<span class="lineno">  179 </span>Note [Left folds via right fold]
<span class="lineno">  180 </span>
<span class="lineno">  181 </span>Implementing foldl et. al. via foldr is only a good idea if the compiler can
<span class="lineno">  182 </span>optimize the resulting code (eta-expand the recursive &quot;go&quot;). See #7994.
<span class="lineno">  183 </span>We hope that one of the two measure kick in:
<span class="lineno">  184 </span>
<span class="lineno">  185 </span>   * Call Arity (-fcall-arity, enabled by default) eta-expands it if it can see
<span class="lineno">  186 </span>     all calls and determine that the arity is large.
<span class="lineno">  187 </span>   * The oneShot annotation gives a hint to the regular arity analysis that
<span class="lineno">  188 </span>     it may assume that the lambda is called at most once.
<span class="lineno">  189 </span>     See [One-shot lambdas] in CoreArity and especially [Eta expanding thunks]
<span class="lineno">  190 </span>     in CoreArity.
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>The oneShot annotations used in this module are correct, as we only use them in
<span class="lineno">  193 </span>argumets to foldr, where we know how the arguments are called.
<span class="lineno">  194 </span>-}
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>-- ----------------------------------------------------------------------------
<span class="lineno">  197 </span>
<span class="lineno">  198 </span>-- | 'foldl1' is a variant of 'foldl' that has no starting value argument,
<span class="lineno">  199 </span>-- and thus must be applied to non-empty lists.
<span class="lineno">  200 </span>foldl1                  :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a
<span class="lineno">  201 </span><span class="decl"><span class="istickedoff">foldl1 f (x:xs)         =  foldl f x xs</span>
<span class="lineno">  202 </span><span class="spaces"></span><span class="istickedoff">foldl1 _ []             =  <span class="nottickedoff">errorEmptyList &quot;foldl1&quot;</span></span></span>
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>-- -----------------------------------------------------------------------------
<span class="lineno">  205 </span>-- List sum and product
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>-- | The 'sum' function computes the sum of a finite list of numbers.
<span class="lineno">  208 </span>sum                     :: (Num a) =&gt; [a] -&gt; a
<span class="lineno">  209 </span>{-# INLINE sum #-}
<span class="lineno">  210 </span><span class="decl"><span class="istickedoff">sum                     =  foldl (+) 0</span></span>
<span class="lineno">  211 </span>
<span class="lineno">  212 </span>-- | The 'product' function computes the product of a finite list of numbers.
<span class="lineno">  213 </span>product                 :: (Num a) =&gt; [a] -&gt; a
<span class="lineno">  214 </span>{-# INLINE product #-}
<span class="lineno">  215 </span><span class="decl"><span class="istickedoff">product                 =  foldl (*) 1</span></span>
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>-- foldr, foldr1, scanr, and scanr1 are the right-to-left duals of the
<span class="lineno">  218 </span>-- above functions.
<span class="lineno">  219 </span>
<span class="lineno">  220 </span>-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
<span class="lineno">  221 </span>-- and thus must be applied to non-empty lists.
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>foldr1                  :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a
<span class="lineno">  224 </span><span class="decl"><span class="istickedoff">foldr1 _ [x]            =  x</span>
<span class="lineno">  225 </span><span class="spaces"></span><span class="istickedoff">foldr1 f (x:xs)         =  f x (foldr1 f xs)</span>
<span class="lineno">  226 </span><span class="spaces"></span><span class="istickedoff">foldr1 _ []             =  <span class="nottickedoff">errorEmptyList &quot;foldr1&quot;</span></span></span>
<span class="lineno">  227 </span>
<span class="lineno">  228 </span>-- | 'maximum' returns the maximum value from a list,
<span class="lineno">  229 </span>-- which must be non-empty, finite, and of an ordered type.
<span class="lineno">  230 </span>-- It is a special case of 'Data.List.maximumBy', which allows the
<span class="lineno">  231 </span>-- programmer to supply their own comparison function.
<span class="lineno">  232 </span>maximum                 :: (Ord a) =&gt; [a] -&gt; a
<span class="lineno">  233 </span>{-# INLINE [1] maximum #-}
<span class="lineno">  234 </span><span class="decl"><span class="istickedoff">maximum []              =  <span class="nottickedoff">errorEmptyList &quot;maximum&quot;</span></span>
<span class="lineno">  235 </span><span class="spaces"></span><span class="istickedoff">maximum xs              =  foldl1 max xs</span></span>
<span class="lineno">  236 </span>
<span class="lineno">  237 </span>-- | 'minimum' returns the minimum value from a list,
<span class="lineno">  238 </span>-- which must be non-empty, finite, and of an ordered type.
<span class="lineno">  239 </span>-- It is a special case of 'Data.List.minimumBy', which allows the
<span class="lineno">  240 </span>-- programmer to supply their own comparison function.
<span class="lineno">  241 </span>minimum                 :: (Ord a) =&gt; [a] -&gt; a
<span class="lineno">  242 </span>{-# INLINE [1] minimum #-}
<span class="lineno">  243 </span><span class="decl"><span class="istickedoff">minimum []              =  <span class="nottickedoff">errorEmptyList &quot;minimum&quot;</span></span>
<span class="lineno">  244 </span><span class="spaces"></span><span class="istickedoff">minimum xs              =  foldl1 min xs</span></span>
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>-- | 'iterate' @f x@ returns an infinite list of repeated applications
<span class="lineno">  248 </span>-- of @f@ to @x@:
<span class="lineno">  249 </span>--
<span class="lineno">  250 </span>-- &gt; iterate f x == [x, f x, f (f x), ...]
<span class="lineno">  251 </span>
<span class="lineno">  252 </span>{-# NOINLINE [1] iterate #-}
<span class="lineno">  253 </span>iterate :: (a -&gt; a) -&gt; a -&gt; [a]
<span class="lineno">  254 </span><span class="decl"><span class="istickedoff">iterate f x =  x : iterate f (f x)</span></span>
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>-- | 'repeat' @x@ is an infinite list, with @x@ the value of every element.
<span class="lineno">  257 </span>repeat :: a -&gt; [a]
<span class="lineno">  258 </span>{-# INLINE [0] repeat #-}
<span class="lineno">  259 </span>-- The pragma just gives the rules more chance to fire
<span class="lineno">  260 </span><span class="decl"><span class="istickedoff">repeat x = xs where xs = x : xs</span></span>
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>-- | 'replicate' @n x@ is a list of length @n@ with @x@ the value of
<span class="lineno">  263 </span>-- every element.
<span class="lineno">  264 </span>-- It is an instance of the more general 'Data.List.genericReplicate',
<span class="lineno">  265 </span>-- in which @n@ may be of any integral type.
<span class="lineno">  266 </span>{-# INLINE replicate #-}
<span class="lineno">  267 </span>replicate               :: Int -&gt; a -&gt; [a]
<span class="lineno">  268 </span><span class="decl"><span class="istickedoff">replicate n x           =  take n (repeat x)</span></span>
<span class="lineno">  269 </span>
<span class="lineno">  270 </span>-- | 'cycle' ties a finite list into a circular one, or equivalently,
<span class="lineno">  271 </span>-- the infinite repetition of the original list.  It is the identity
<span class="lineno">  272 </span>-- on infinite lists.
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>cycle                   :: [a] -&gt; [a]
<span class="lineno">  275 </span><span class="decl"><span class="istickedoff">cycle []                = <span class="nottickedoff">errorEmptyList &quot;cycle&quot;</span></span>
<span class="lineno">  276 </span><span class="spaces"></span><span class="istickedoff">cycle xs                = xs' where xs' = xs ++ xs'</span></span>
<span class="lineno">  277 </span>
<span class="lineno">  278 </span>-- | 'takeWhile', applied to a predicate @p@ and a list @xs@, returns the
<span class="lineno">  279 </span>-- longest prefix (possibly empty) of @xs@ of elements that satisfy @p@:
<span class="lineno">  280 </span>--
<span class="lineno">  281 </span>-- &gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
<span class="lineno">  282 </span>-- &gt; takeWhile (&lt; 9) [1,2,3] == [1,2,3]
<span class="lineno">  283 </span>-- &gt; takeWhile (&lt; 0) [1,2,3] == []
<span class="lineno">  284 </span>--
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>{-# NOINLINE [1] takeWhile #-}
<span class="lineno">  287 </span>takeWhile               :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
<span class="lineno">  288 </span><span class="decl"><span class="istickedoff">takeWhile _ []          =  []</span>
<span class="lineno">  289 </span><span class="spaces"></span><span class="istickedoff">takeWhile p (x:xs)</span>
<span class="lineno">  290 </span><span class="spaces">            </span><span class="istickedoff">| p x       =  x : takeWhile p xs</span>
<span class="lineno">  291 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =  []</span></span>
<span class="lineno">  292 </span>
<span class="lineno">  293 </span>-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@:
<span class="lineno">  294 </span>--
<span class="lineno">  295 </span>-- &gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
<span class="lineno">  296 </span>-- &gt; dropWhile (&lt; 9) [1,2,3] == []
<span class="lineno">  297 </span>-- &gt; dropWhile (&lt; 0) [1,2,3] == [1,2,3]
<span class="lineno">  298 </span>--
<span class="lineno">  299 </span>
<span class="lineno">  300 </span>dropWhile               :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
<span class="lineno">  301 </span><span class="decl"><span class="istickedoff">dropWhile _ []          =  []</span>
<span class="lineno">  302 </span><span class="spaces"></span><span class="istickedoff">dropWhile p xs@(x:xs')</span>
<span class="lineno">  303 </span><span class="spaces">            </span><span class="istickedoff">| p x       =  dropWhile p xs'</span>
<span class="lineno">  304 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =  xs</span></span>
<span class="lineno">  305 </span>
<span class="lineno">  306 </span>-- | 'take' @n@, applied to a list @xs@, returns the prefix of @xs@
<span class="lineno">  307 </span>-- of length @n@, or @xs@ itself if @n &gt; 'length' xs@:
<span class="lineno">  308 </span>--
<span class="lineno">  309 </span>-- &gt; take 5 &quot;Hello World!&quot; == &quot;Hello&quot;
<span class="lineno">  310 </span>-- &gt; take 3 [1,2,3,4,5] == [1,2,3]
<span class="lineno">  311 </span>-- &gt; take 3 [1,2] == [1,2]
<span class="lineno">  312 </span>-- &gt; take 3 [] == []
<span class="lineno">  313 </span>-- &gt; take (-1) [1,2] == []
<span class="lineno">  314 </span>-- &gt; take 0 [1,2] == []
<span class="lineno">  315 </span>--
<span class="lineno">  316 </span>-- It is an instance of the more general 'Data.List.genericTake',
<span class="lineno">  317 </span>-- in which @n@ may be of any integral type.
<span class="lineno">  318 </span>take                   :: Int -&gt; [a] -&gt; [a]
<span class="lineno">  319 </span>#ifdef USE_REPORT_PRELUDE
<span class="lineno">  320 </span>take n _      | n &lt;= 0 =  []
<span class="lineno">  321 </span>take _ []              =  []
<span class="lineno">  322 </span>take n (x:xs)          =  x : take (n-1) xs
<span class="lineno">  323 </span>#else
<span class="lineno">  324 </span>
<span class="lineno">  325 </span>{- We always want to inline this to take advantage of a known length argument
<span class="lineno">  326 </span>sign. Note, however, that it's important for the RULES to grab take, rather
<span class="lineno">  327 </span>than trying to INLINE take immediately and then letting the RULES grab
<span class="lineno">  328 </span>unsafeTake. Presumably the latter approach doesn't grab it early enough; it led
<span class="lineno">  329 </span>to an allocation regression in nofib/fft2. -}
<span class="lineno">  330 </span>{-# INLINE [1] take #-}
<span class="lineno">  331 </span><span class="decl"><span class="istickedoff">take n xs | 0 &lt; n     = unsafeTake n xs</span>
<span class="lineno">  332 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = []</span></span>
<span class="lineno">  333 </span>
<span class="lineno">  334 </span>-- A version of take that takes the whole list if it's given an argument less
<span class="lineno">  335 </span>-- than 1.
<span class="lineno">  336 </span>{-# NOINLINE [1] unsafeTake #-}
<span class="lineno">  337 </span>unsafeTake :: Int -&gt; [a] -&gt; [a]
<span class="lineno">  338 </span><span class="decl"><span class="istickedoff">unsafeTake !_  []     = []</span>
<span class="lineno">  339 </span><span class="spaces"></span><span class="istickedoff">unsafeTake 1   (x: _) = [x]</span>
<span class="lineno">  340 </span><span class="spaces"></span><span class="istickedoff">unsafeTake m   (x:xs) = x : unsafeTake (m - 1) xs</span></span>
<span class="lineno">  341 </span>
<span class="lineno">  342 </span>#endif
<span class="lineno">  343 </span>
<span class="lineno">  344 </span>-- | 'drop' @n xs@ returns the suffix of @xs@
<span class="lineno">  345 </span>-- after the first @n@ elements, or @[]@ if @n &gt; 'length' xs@:
<span class="lineno">  346 </span>--
<span class="lineno">  347 </span>-- &gt; drop 6 &quot;Hello World!&quot; == &quot;World!&quot;
<span class="lineno">  348 </span>-- &gt; drop 3 [1,2,3,4,5] == [4,5]
<span class="lineno">  349 </span>-- &gt; drop 3 [1,2] == []
<span class="lineno">  350 </span>-- &gt; drop 3 [] == []
<span class="lineno">  351 </span>-- &gt; drop (-1) [1,2] == [1,2]
<span class="lineno">  352 </span>-- &gt; drop 0 [1,2] == [1,2]
<span class="lineno">  353 </span>--
<span class="lineno">  354 </span>-- It is an instance of the more general 'Data.List.genericDrop',
<span class="lineno">  355 </span>-- in which @n@ may be of any integral type.
<span class="lineno">  356 </span>drop                   :: Int -&gt; [a] -&gt; [a]
<span class="lineno">  357 </span>#ifdef USE_REPORT_PRELUDE
<span class="lineno">  358 </span>drop n xs     | n &lt;= 0 =  xs
<span class="lineno">  359 </span>drop _ []              =  []
<span class="lineno">  360 </span>drop n (_:xs)          =  drop (n-1) xs
<span class="lineno">  361 </span>#else /* hack away */
<span class="lineno">  362 </span>{-# INLINE drop #-}
<span class="lineno">  363 </span><span class="decl"><span class="istickedoff">drop n ls</span>
<span class="lineno">  364 </span><span class="spaces">  </span><span class="istickedoff">| n &lt;= 0     = ls</span>
<span class="lineno">  365 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>  = unsafeDrop n ls</span>
<span class="lineno">  366 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  367 </span><span class="spaces">    </span><span class="istickedoff">-- A version of drop that drops the whole list if given an argument</span>
<span class="lineno">  368 </span><span class="spaces">    </span><span class="istickedoff">-- less than 1</span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="istickedoff">unsafeDrop :: Int -&gt; [a] -&gt; [a]</span>
<span class="lineno">  370 </span><span class="spaces">    </span><span class="istickedoff">unsafeDrop !_ []     = []</span>
<span class="lineno">  371 </span><span class="spaces">    </span><span class="istickedoff">unsafeDrop 1  (_:xs) = xs</span>
<span class="lineno">  372 </span><span class="spaces">    </span><span class="istickedoff">unsafeDrop m  (_:xs) = unsafeDrop (m - 1) xs</span></span>
<span class="lineno">  373 </span>#endif
<span class="lineno">  374 </span>
<span class="lineno">  375 </span>-- | 'splitAt' @n xs@ returns a tuple where first element is @xs@ prefix of
<span class="lineno">  376 </span>-- length @n@ and second element is the remainder of the list:
<span class="lineno">  377 </span>--
<span class="lineno">  378 </span>-- &gt; splitAt 6 &quot;Hello World!&quot; == (&quot;Hello &quot;,&quot;World!&quot;)
<span class="lineno">  379 </span>-- &gt; splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
<span class="lineno">  380 </span>-- &gt; splitAt 1 [1,2,3] == ([1],[2,3])
<span class="lineno">  381 </span>-- &gt; splitAt 3 [1,2,3] == ([1,2,3],[])
<span class="lineno">  382 </span>-- &gt; splitAt 4 [1,2,3] == ([1,2,3],[])
<span class="lineno">  383 </span>-- &gt; splitAt 0 [1,2,3] == ([],[1,2,3])
<span class="lineno">  384 </span>-- &gt; splitAt (-1) [1,2,3] == ([],[1,2,3])
<span class="lineno">  385 </span>--
<span class="lineno">  386 </span>-- It is equivalent to @('take' n xs, 'drop' n xs)@ when @n@ is not @_|_@
<span class="lineno">  387 </span>-- (@splitAt _|_ xs = _|_@).
<span class="lineno">  388 </span>-- 'splitAt' is an instance of the more general 'Data.List.genericSplitAt',
<span class="lineno">  389 </span>-- in which @n@ may be of any integral type.
<span class="lineno">  390 </span>splitAt                :: Int -&gt; [a] -&gt; ([a],[a])
<span class="lineno">  391 </span>
<span class="lineno">  392 </span>#ifdef USE_REPORT_PRELUDE
<span class="lineno">  393 </span>splitAt n xs           =  (take n xs, drop n xs)
<span class="lineno">  394 </span>#else
<span class="lineno">  395 </span><span class="decl"><span class="istickedoff">splitAt n ls</span>
<span class="lineno">  396 </span><span class="spaces">  </span><span class="istickedoff">| n &lt;= 0 = ([], ls)</span>
<span class="lineno">  397 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>          = splitAt' n ls</span>
<span class="lineno">  398 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  399 </span><span class="spaces">        </span><span class="istickedoff">splitAt' :: Int -&gt; [a] -&gt; ([a], [a])</span>
<span class="lineno">  400 </span><span class="spaces">        </span><span class="istickedoff">splitAt' _  []     = ([], [])</span>
<span class="lineno">  401 </span><span class="spaces">        </span><span class="istickedoff">splitAt' 1  (x:xs) = ([x], xs)</span>
<span class="lineno">  402 </span><span class="spaces">        </span><span class="istickedoff">splitAt' m  (x:xs) = (x:xs', xs'')</span>
<span class="lineno">  403 </span><span class="spaces">          </span><span class="istickedoff">where</span>
<span class="lineno">  404 </span><span class="spaces">            </span><span class="istickedoff">(xs', xs'') = splitAt' (m - 1) xs</span></span>
<span class="lineno">  405 </span>#endif /* USE_REPORT_PRELUDE */
<span class="lineno">  406 </span>
<span class="lineno">  407 </span>-- | 'span', applied to a predicate @p@ and a list @xs@, returns a tuple where
<span class="lineno">  408 </span>-- first element is longest prefix (possibly empty) of @xs@ of elements that
<span class="lineno">  409 </span>-- satisfy @p@ and second element is the remainder of the list:
<span class="lineno">  410 </span>--
<span class="lineno">  411 </span>-- &gt; span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
<span class="lineno">  412 </span>-- &gt; span (&lt; 9) [1,2,3] == ([1,2,3],[])
<span class="lineno">  413 </span>-- &gt; span (&lt; 0) [1,2,3] == ([],[1,2,3])
<span class="lineno">  414 </span>--
<span class="lineno">  415 </span>-- 'span' @p xs@ is equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
<span class="lineno">  416 </span>
<span class="lineno">  417 </span>span                    :: (a -&gt; Bool) -&gt; [a] -&gt; ([a],[a])
<span class="lineno">  418 </span><span class="decl"><span class="istickedoff">span _ xs@[]            =  (xs, xs)</span>
<span class="lineno">  419 </span><span class="spaces"></span><span class="istickedoff">span p xs@(x:xs')</span>
<span class="lineno">  420 </span><span class="spaces">         </span><span class="istickedoff">| p x          =  let (ys,zs) = span p xs' in (x:ys,zs)</span>
<span class="lineno">  421 </span><span class="spaces">         </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>    =  ([],xs)</span></span>
<span class="lineno">  422 </span>
<span class="lineno">  423 </span>-- | 'break', applied to a predicate @p@ and a list @xs@, returns a tuple where
<span class="lineno">  424 </span>-- first element is longest prefix (possibly empty) of @xs@ of elements that
<span class="lineno">  425 </span>-- /do not satisfy/ @p@ and second element is the remainder of the list:
<span class="lineno">  426 </span>--
<span class="lineno">  427 </span>-- &gt; break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
<span class="lineno">  428 </span>-- &gt; break (&lt; 9) [1,2,3] == ([],[1,2,3])
<span class="lineno">  429 </span>-- &gt; break (&gt; 9) [1,2,3] == ([1,2,3],[])
<span class="lineno">  430 </span>--
<span class="lineno">  431 </span>-- 'break' @p@ is equivalent to @'span' ('not' . p)@.
<span class="lineno">  432 </span>
<span class="lineno">  433 </span>break                   :: (a -&gt; Bool) -&gt; [a] -&gt; ([a],[a])
<span class="lineno">  434 </span>#ifdef USE_REPORT_PRELUDE
<span class="lineno">  435 </span>break p                 =  span (not . p)
<span class="lineno">  436 </span>#else
<span class="lineno">  437 </span>-- HBC version (stolen)
<span class="lineno">  438 </span><span class="decl"><span class="istickedoff">break _ xs@[]           =  (xs, xs)</span>
<span class="lineno">  439 </span><span class="spaces"></span><span class="istickedoff">break p xs@(x:xs')</span>
<span class="lineno">  440 </span><span class="spaces">           </span><span class="istickedoff">| p x        =  ([],xs)</span>
<span class="lineno">  441 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>  =  let (ys,zs) = break p xs' in (x:ys,zs)</span></span>
<span class="lineno">  442 </span>#endif
<span class="lineno">  443 </span>
<span class="lineno">  444 </span>-- | 'reverse' @xs@ returns the elements of @xs@ in reverse order.
<span class="lineno">  445 </span>-- @xs@ must be finite.
<span class="lineno">  446 </span>reverse                 :: [a] -&gt; [a]
<span class="lineno">  447 </span>#ifdef USE_REPORT_PRELUDE
<span class="lineno">  448 </span>reverse                 =  foldl (flip (:)) []
<span class="lineno">  449 </span>#else
<span class="lineno">  450 </span><span class="decl"><span class="istickedoff">reverse l =  rev l []</span>
<span class="lineno">  451 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  452 </span><span class="spaces">    </span><span class="istickedoff">rev []     a = a</span>
<span class="lineno">  453 </span><span class="spaces">    </span><span class="istickedoff">rev (x:xs) a = rev xs (x:a)</span></span>
<span class="lineno">  454 </span>#endif
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>-- | The 'subsequences' function returns the list of all subsequences of the argument.
<span class="lineno">  457 </span>--
<span class="lineno">  458 </span>-- &gt; subsequences &quot;abc&quot; == [&quot;&quot;,&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;,&quot;c&quot;,&quot;ac&quot;,&quot;bc&quot;,&quot;abc&quot;]
<span class="lineno">  459 </span>subsequences            :: [a] -&gt; [[a]]
<span class="lineno">  460 </span><span class="decl"><span class="istickedoff">subsequences xs         =  [] : nonEmptySubsequences xs</span></span>
<span class="lineno">  461 </span>
<span class="lineno">  462 </span>-- | The 'nonEmptySubsequences' function returns the list of all subsequences of the argument,
<span class="lineno">  463 </span>--   except for the empty list.
<span class="lineno">  464 </span>--
<span class="lineno">  465 </span>-- &gt; nonEmptySubsequences &quot;abc&quot; == [&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;,&quot;c&quot;,&quot;ac&quot;,&quot;bc&quot;,&quot;abc&quot;]
<span class="lineno">  466 </span>nonEmptySubsequences         :: [a] -&gt; [[a]]
<span class="lineno">  467 </span><span class="decl"><span class="istickedoff">nonEmptySubsequences []      =  []</span>
<span class="lineno">  468 </span><span class="spaces"></span><span class="istickedoff">nonEmptySubsequences (x:xs)  =  [x] : foldr f [] (nonEmptySubsequences xs)</span>
<span class="lineno">  469 </span><span class="spaces">  </span><span class="istickedoff">where f ys r = ys : (x : ys) : r</span></span>
<span class="lineno">  470 </span>
<span class="lineno">  471 </span>
<span class="lineno">  472 </span>-- | The 'permutations' function returns the list of all permutations of the argument.
<span class="lineno">  473 </span>--
<span class="lineno">  474 </span>-- &gt; permutations &quot;abc&quot; == [&quot;abc&quot;,&quot;bac&quot;,&quot;cba&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;acb&quot;]
<span class="lineno">  475 </span>permutations            :: [a] -&gt; [[a]]
<span class="lineno">  476 </span><span class="decl"><span class="istickedoff">permutations xs0        =  xs0 : perms xs0 []</span>
<span class="lineno">  477 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  478 </span><span class="spaces">    </span><span class="istickedoff">perms []     _  = []</span>
<span class="lineno">  479 </span><span class="spaces">    </span><span class="istickedoff">perms (t:ts) is = foldr interleave (perms ts (t:is)) (permutations is)</span>
<span class="lineno">  480 </span><span class="spaces">      </span><span class="istickedoff">where interleave    xs     r = let (_,zs) = interleave' id xs r in zs</span>
<span class="lineno">  481 </span><span class="spaces">            </span><span class="istickedoff">interleave' _ []     r = (ts, r)</span>
<span class="lineno">  482 </span><span class="spaces">            </span><span class="istickedoff">interleave' f (y:ys) r = let (us,zs) = interleave' (f . (y:)) ys r</span>
<span class="lineno">  483 </span><span class="spaces">                                     </span><span class="istickedoff">in  (y:us, f (t:y:us) : zs)</span></span>
<span class="lineno">  484 </span>
<span class="lineno">  485 </span>
<span class="lineno">  486 </span>-- | The 'intersperse' function takes an element and a list and
<span class="lineno">  487 </span>-- \`intersperses\' that element between the elements of the list.
<span class="lineno">  488 </span>-- For example,
<span class="lineno">  489 </span>--
<span class="lineno">  490 </span>-- &gt; intersperse ',' &quot;abcde&quot; == &quot;a,b,c,d,e&quot;
<span class="lineno">  491 </span>
<span class="lineno">  492 </span>intersperse             :: a -&gt; [a] -&gt; [a]
<span class="lineno">  493 </span><span class="decl"><span class="istickedoff">intersperse _   []      = []</span>
<span class="lineno">  494 </span><span class="spaces"></span><span class="istickedoff">intersperse sep (x:xs)  = x : prependToAll sep xs</span></span>
<span class="lineno">  495 </span>
<span class="lineno">  496 </span>
<span class="lineno">  497 </span>-- Not exported:
<span class="lineno">  498 </span>-- We want to make every element in the 'intersperse'd list available
<span class="lineno">  499 </span>-- as soon as possible to avoid space leaks. Experiments suggested that
<span class="lineno">  500 </span>-- a separate top-level helper is more efficient than a local worker.
<span class="lineno">  501 </span>prependToAll            :: a -&gt; [a] -&gt; [a]
<span class="lineno">  502 </span><span class="decl"><span class="istickedoff">prependToAll _   []     = []</span>
<span class="lineno">  503 </span><span class="spaces"></span><span class="istickedoff">prependToAll sep (x:xs) = sep : x : prependToAll sep xs</span></span>
<span class="lineno">  504 </span>
<span class="lineno">  505 </span>-- | 'intercalate' @xs xss@ is equivalent to @('concat' ('intersperse' xs xss))@.
<span class="lineno">  506 </span>-- It inserts the list @xs@ in between the lists in @xss@ and concatenates the
<span class="lineno">  507 </span>-- result.
<span class="lineno">  508 </span>intercalate :: [a] -&gt; [[a]] -&gt; [a]
<span class="lineno">  509 </span><span class="decl"><span class="istickedoff">intercalate xs xss = concat (intersperse xs xss)</span></span>
<span class="lineno">  510 </span>
<span class="lineno">  511 </span>-- | 'and' returns the conjunction of a Boolean list.  For the result to be
<span class="lineno">  512 </span>-- 'True', the list must be finite; 'False', however, results from a 'False'
<span class="lineno">  513 </span>-- value at a finite index of a finite or infinite list.
<span class="lineno">  514 </span>and                     :: [Bool] -&gt; Bool
<span class="lineno">  515 </span>#ifdef USE_REPORT_PRELUDE
<span class="lineno">  516 </span>and                     =  foldr (&amp;&amp;) True
<span class="lineno">  517 </span>#else
<span class="lineno">  518 </span><span class="decl"><span class="istickedoff">and []          =  True</span>
<span class="lineno">  519 </span><span class="spaces"></span><span class="istickedoff">and (x:xs)      =  x &amp;&amp; and xs</span></span>
<span class="lineno">  520 </span>{-# NOINLINE [1] and #-}
<span class="lineno">  521 </span>
<span class="lineno">  522 </span>{-# RULES
<span class="lineno">  523 </span>&quot;and/build&quot;     forall (g::forall b.(Bool-&gt;b-&gt;b)-&gt;b-&gt;b) .
<span class="lineno">  524 </span>                and (build g) = g (&amp;&amp;) True
<span class="lineno">  525 </span> #-}
<span class="lineno">  526 </span>#endif
<span class="lineno">  527 </span>
<span class="lineno">  528 </span>-- | 'or' returns the disjunction of a Boolean list.  For the result to be
<span class="lineno">  529 </span>-- 'False', the list must be finite; 'True', however, results from a 'True'
<span class="lineno">  530 </span>-- value at a finite index of a finite or infinite list.
<span class="lineno">  531 </span>or                      :: [Bool] -&gt; Bool
<span class="lineno">  532 </span>#ifdef USE_REPORT_PRELUDE
<span class="lineno">  533 </span>or                      =  foldr (||) False
<span class="lineno">  534 </span>#else
<span class="lineno">  535 </span><span class="decl"><span class="istickedoff">or []           =  False</span>
<span class="lineno">  536 </span><span class="spaces"></span><span class="istickedoff">or (x:xs)       =  x || or xs</span></span>
<span class="lineno">  537 </span>{-# NOINLINE [1] or #-}
<span class="lineno">  538 </span>
<span class="lineno">  539 </span>{-# RULES
<span class="lineno">  540 </span>&quot;or/build&quot;      forall (g::forall b.(Bool-&gt;b-&gt;b)-&gt;b-&gt;b) .
<span class="lineno">  541 </span>                or (build g) = g (||) False
<span class="lineno">  542 </span> #-}
<span class="lineno">  543 </span>#endif
<span class="lineno">  544 </span>
<span class="lineno">  545 </span>-- | 'elem' is the list membership predicate, usually written in infix form,
<span class="lineno">  546 </span>-- e.g., @x \`elem\` xs@.  For the result to be
<span class="lineno">  547 </span>-- 'False', the list must be finite; 'True', however, results from an element
<span class="lineno">  548 </span>-- equal to @x@ found at a finite index of a finite or infinite list.
<span class="lineno">  549 </span>elem                    :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
<span class="lineno">  550 </span>#ifdef USE_REPORT_PRELUDE
<span class="lineno">  551 </span>elem x                  =  any (== x)
<span class="lineno">  552 </span>#else
<span class="lineno">  553 </span><span class="decl"><span class="istickedoff">elem _ []       = False</span>
<span class="lineno">  554 </span><span class="spaces"></span><span class="istickedoff">elem x (y:ys)   = x==y || elem x ys</span></span>
<span class="lineno">  555 </span>{-# NOINLINE [1] elem #-}
<span class="lineno">  556 </span>{-# RULES
<span class="lineno">  557 </span>&quot;elem/build&quot;    forall x (g :: forall b . Eq a =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; b)
<span class="lineno">  558 </span>   . elem x (build g) = g (\ y r -&gt; (x == y) || r) False
<span class="lineno">  559 </span> #-}
<span class="lineno">  560 </span>#endif
<span class="lineno">  561 </span>
<span class="lineno">  562 </span>-- | 'notElem' is the negation of 'elem'.
<span class="lineno">  563 </span>notElem                 :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
<span class="lineno">  564 </span>#ifdef USE_REPORT_PRELUDE
<span class="lineno">  565 </span>notElem x               =  all (/= x)
<span class="lineno">  566 </span>#else
<span class="lineno">  567 </span><span class="decl"><span class="istickedoff">notElem _ []    =  True</span>
<span class="lineno">  568 </span><span class="spaces"></span><span class="istickedoff">notElem x (y:ys)=  x /= y &amp;&amp; notElem x ys</span></span>
<span class="lineno">  569 </span>{-# NOINLINE [1] notElem #-}
<span class="lineno">  570 </span>{-# RULES
<span class="lineno">  571 </span>&quot;notElem/build&quot; forall x (g :: forall b . Eq a =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; b)
<span class="lineno">  572 </span>   . notElem x (build g) = g (\ y r -&gt; (x /= y) &amp;&amp; r) True
<span class="lineno">  573 </span> #-}
<span class="lineno">  574 </span>#endif
<span class="lineno">  575 </span>
<span class="lineno">  576 </span>-- | 'lookup' @key assocs@ looks up a key in an association list.
<span class="lineno">  577 </span>lookup                  :: (Eq a) =&gt; a -&gt; [(a,b)] -&gt; Maybe b
<span class="lineno">  578 </span><span class="decl"><span class="istickedoff">lookup _key []          =  Nothing</span>
<span class="lineno">  579 </span><span class="spaces"></span><span class="istickedoff">lookup  key ((x,y):xys)</span>
<span class="lineno">  580 </span><span class="spaces">    </span><span class="istickedoff">| key == x          =  Just y</span>
<span class="lineno">  581 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>         =  lookup key xys</span></span>
<span class="lineno">  582 </span>
<span class="lineno">  583 </span>-- | Map a function over a list and concatenate the results.
<span class="lineno">  584 </span>concatMap               :: (a -&gt; [b]) -&gt; [a] -&gt; [b]
<span class="lineno">  585 </span><span class="decl"><span class="istickedoff">concatMap f             =  foldr ((++) . f) []</span></span>
<span class="lineno">  586 </span>
<span class="lineno">  587 </span>{-# NOINLINE [1] concatMap #-}
<span class="lineno">  588 </span>
<span class="lineno">  589 </span>{-# RULES
<span class="lineno">  590 </span>&quot;concatMap&quot; forall f xs . concatMap f xs =
<span class="lineno">  591 </span>    build (\c n -&gt; foldr (\x b -&gt; foldr c b (f x)) n xs)
<span class="lineno">  592 </span> #-}
<span class="lineno">  593 </span>
<span class="lineno">  594 </span>
<span class="lineno">  595 </span>-- | Concatenate a list of lists.
<span class="lineno">  596 </span>concat :: [[a]] -&gt; [a]
<span class="lineno">  597 </span><span class="decl"><span class="istickedoff">concat = foldr (++) []</span></span>
<span class="lineno">  598 </span>
<span class="lineno">  599 </span>{-# NOINLINE [1] concat #-}
<span class="lineno">  600 </span>
<span class="lineno">  601 </span>{-# RULES
<span class="lineno">  602 </span>  &quot;concat&quot; forall xs. concat xs =
<span class="lineno">  603 </span>     build (\c n -&gt; foldr (\x y -&gt; foldr c y x) n xs)
<span class="lineno">  604 </span>-- We don't bother to turn non-fusible applications of concat back into concat
<span class="lineno">  605 </span> #-}
<span class="lineno">  606 </span>
<span class="lineno">  607 </span>-- | List index (subscript) operator, starting from 0.
<span class="lineno">  608 </span>-- It is an instance of the more general 'Data.List.genericIndex',
<span class="lineno">  609 </span>-- which takes an index of any integral type.
<span class="lineno">  610 </span>(!!)                    :: [a] -&gt; Int -&gt; a
<span class="lineno">  611 </span>#ifdef USE_REPORT_PRELUDE
<span class="lineno">  612 </span>xs     !! n | n &lt; 0 =  error &quot;Prelude.!!: negative index&quot;
<span class="lineno">  613 </span>[]     !! _         =  error &quot;Prelude.!!: index too large&quot;
<span class="lineno">  614 </span>(x:_)  !! 0         =  x
<span class="lineno">  615 </span>(_:xs) !! n         =  xs !! (n-1)
<span class="lineno">  616 </span>#else
<span class="lineno">  617 </span>
<span class="lineno">  618 </span>-- We don't really want the errors to inline with (!!).
<span class="lineno">  619 </span>-- We may want to fuss around a bit with NOINLINE, and
<span class="lineno">  620 </span>-- if so we should be careful not to trip up known-bottom
<span class="lineno">  621 </span>-- optimizations.
<span class="lineno">  622 </span>tooLarge :: Int -&gt; a
<span class="lineno">  623 </span><span class="decl"><span class="nottickedoff">tooLarge _ = error (prel_list_str ++ &quot;!!: index too large&quot;)</span></span>
<span class="lineno">  624 </span>
<span class="lineno">  625 </span>negIndex :: a
<span class="lineno">  626 </span><span class="decl"><span class="nottickedoff">negIndex = error $ prel_list_str ++ &quot;!!: negative index&quot;</span></span>
<span class="lineno">  627 </span>
<span class="lineno">  628 </span>{-# INLINABLE (!!) #-}
<span class="lineno">  629 </span><span class="decl"><span class="istickedoff">xs !! n</span>
<span class="lineno">  630 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlyfalse">n &lt; 0</span>     = <span class="nottickedoff">negIndex</span></span>
<span class="lineno">  631 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = foldr (\x r k -&gt; case k of</span>
<span class="lineno">  632 </span><span class="spaces">                                   </span><span class="istickedoff">0 -&gt; x</span>
<span class="lineno">  633 </span><span class="spaces">                                   </span><span class="istickedoff">_ -&gt; r (k-1)) <span class="nottickedoff">tooLarge</span> xs n</span></span>
<span class="lineno">  634 </span>#endif
<span class="lineno">  635 </span>
<span class="lineno">  636 </span>--------------------------------------------------------------
<span class="lineno">  637 </span>-- The zip family
<span class="lineno">  638 </span>--------------------------------------------------------------
<span class="lineno">  639 </span>
<span class="lineno">  640 </span>----------------------------------------------
<span class="lineno">  641 </span>-- | 'zip' takes two lists and returns a list of corresponding pairs.
<span class="lineno">  642 </span>-- If one input list is short, excess elements of the longer list are
<span class="lineno">  643 </span>-- discarded.
<span class="lineno">  644 </span>--
<span class="lineno">  645 </span>-- 'zip' is right-lazy:
<span class="lineno">  646 </span>--
<span class="lineno">  647 </span>-- &gt; zip [] _|_ = []
<span class="lineno">  648 </span>{-# NOINLINE [1] zip #-}
<span class="lineno">  649 </span>zip :: [a] -&gt; [b] -&gt; [(a,b)]
<span class="lineno">  650 </span><span class="decl"><span class="istickedoff">zip []     _bs    = []</span>
<span class="lineno">  651 </span><span class="spaces"></span><span class="istickedoff">zip _as    []     = []</span>
<span class="lineno">  652 </span><span class="spaces"></span><span class="istickedoff">zip (a:as) (b:bs) = (a,b) : zip as bs</span></span>
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>-- The zipWith family generalises the zip family by zipping with the
<span class="lineno">  655 </span>-- function given as the first argument, instead of a tupling function.
<span class="lineno">  656 </span>
<span class="lineno">  657 </span>----------------------------------------------
<span class="lineno">  658 </span>-- | 'zipWith' generalises 'zip' by zipping with the function given
<span class="lineno">  659 </span>-- as the first argument, instead of a tupling function.
<span class="lineno">  660 </span>-- For example, @'zipWith' (+)@ is applied to two lists to produce the
<span class="lineno">  661 </span>-- list of corresponding sums.
<span class="lineno">  662 </span>--
<span class="lineno">  663 </span>-- 'zipWith' is right-lazy:
<span class="lineno">  664 </span>--
<span class="lineno">  665 </span>-- &gt; zipWith f [] _|_ = []
<span class="lineno">  666 </span>{-# NOINLINE [1] zipWith #-}
<span class="lineno">  667 </span>zipWith :: (a-&gt;b-&gt;c) -&gt; [a]-&gt;[b]-&gt;[c]
<span class="lineno">  668 </span><span class="decl"><span class="istickedoff">zipWith _f []     _bs    = []</span>
<span class="lineno">  669 </span><span class="spaces"></span><span class="istickedoff">zipWith _f _as    []     = []</span>
<span class="lineno">  670 </span><span class="spaces"></span><span class="istickedoff">zipWith f  (a:as) (b:bs) = f a b : zipWith f as bs</span></span>
<span class="lineno">  671 </span>
<span class="lineno">  672 </span>-- | 'unzip' transforms a list of pairs into a list of first components
<span class="lineno">  673 </span>-- and a list of second components.
<span class="lineno">  674 </span>unzip    :: [(a,b)] -&gt; ([a],[b])
<span class="lineno">  675 </span>{-# INLINE unzip #-}
<span class="lineno">  676 </span><span class="decl"><span class="istickedoff">unzip    =  foldr (\(a,b) ~(as,bs) -&gt; (a:as,b:bs)) ([],[])</span></span>
<span class="lineno">  677 </span>
<span class="lineno">  678 </span>--------------------------------------------------------------
<span class="lineno">  679 </span>-- Error code
<span class="lineno">  680 </span>--------------------------------------------------------------
<span class="lineno">  681 </span>
<span class="lineno">  682 </span>-- Common up near identical calls to `error' to reduce the number
<span class="lineno">  683 </span>-- constant strings created when compiled:
<span class="lineno">  684 </span>
<span class="lineno">  685 </span>errorEmptyList :: String -&gt; a
<span class="lineno">  686 </span><span class="decl"><span class="nottickedoff">errorEmptyList fun =</span>
<span class="lineno">  687 </span><span class="spaces">  </span><span class="nottickedoff">error (prel_list_str ++ fun ++ &quot;: empty list&quot;)</span></span>
<span class="lineno">  688 </span>
<span class="lineno">  689 </span>prel_list_str :: String
<span class="lineno">  690 </span><span class="decl"><span class="nottickedoff">prel_list_str = &quot;Prelude.&quot;</span></span>

</pre>
</body>
</html>
